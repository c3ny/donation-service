# JWT Authentication Setup Guide

## Overview

The donation-service validates JWT tokens generated by the **users-service**. JWT authentication is required for the following endpoints:

- `POST /donations` - Create donation
- `PUT /donations/:id/status` - Update donation status
- `DELETE /donations/:id` - Delete donation

## Architecture

```
┌─────────────────┐        ┌─────────────────┐        ┌──────────────────┐
│  Frontend App   │───────▶│  Users Service  │        │ Donation Service │
│                 │        │  (Port 3002)    │        │  (Port 8080)     │
│                 │        │                 │        │                  │
│  1. Login       │        │  2. Generates   │        │  3. Validates    │
│     Request     │        │     JWT Token   │───────▶│     JWT Token    │
│                 │        │                 │        │                  │
└─────────────────┘        └─────────────────┘        └──────────────────┘
```

## Environment Configuration

Add the following to your `.env` file:

```env
JWT_SECRET=your-super-secret-jwt-key-change-in-production
```

⚠️ **Critical**: The `JWT_SECRET` **must be identical** in both:

- `users-service/.env`
- `donation-service/.env`

⚠️ **Important**:

- Use a strong, randomly generated secret in production
- Never commit the JWT_SECRET to version control
- Rotate secrets regularly in both services simultaneously

## Token Format

The JWT token from users-service has the following payload structure:

```json
{
  "id": "50f05b0c-5ce0-4920-9960-11f733f713a7",
  "email": "user@example.com",
  "personType": "DONOR",
  "iat": 1623456789
}
```

## Testing with cURL

### 1. Get a JWT Token from Users Service

**Step 1: Register a user** (if not already registered):

```bash
curl -X POST http://localhost:3002/users \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "Test123!",
    "name": "Test User",
    "city": "São Paulo",
    "uf": "SP",
    "personType": "DONOR",
    "cpf": "123.456.789-00",
    "bloodType": "O+",
    "birthDate": "1990-01-01"
  }'
```

**Step 2: Login to get JWT token**:

```bash
curl -X POST http://localhost:3002/users/authenticate \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "Test123!"
  }'
```

**Response**:

```json
{
  "user": {
    "id": "50f05b0c-5ce0-4920-9960-11f733f713a7",
    "email": "test@example.com",
    "name": "Test User",
    "personType": "DONOR",
    ...
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUwZjA1YjBjLTVjZTAtNDkyMC05OTYwLTExZjczM2Y3MTNhNyIsImVtYWlsIjoidGVzdEBleGFtcGxlLmNvbSIsInBlcnNvblR5cGUiOiJET05PUiIsImlhdCI6MTYyMzQ1Njc4OX0.xyz..."
}
```

**Step 3: Copy the token** from the response and use it in the donation-service requests.

### 2. Test Protected Endpoints

**Create Donation:**

```bash
curl -X POST http://localhost:8080/donations \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "status": "PENDING",
    "content": "Need O+ blood urgently",
    "startDate": "2025-10-20T10:00:00.000Z",
    "bloodType": "O+",
    "location": {
      "latitude": -23.5505,
      "longitude": -46.6333
    },
    "userId": "user123"
  }'
```

**Update Status:**

```bash
curl -X PUT http://localhost:8080/donations/DONATION_ID/status \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "status": "APPROVED"
  }'
```

**Delete Donation:**

```bash
curl -X DELETE http://localhost:8080/donations/DONATION_ID \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

## Testing with Postman

1. Create a new request
2. Set the method (POST, PUT, DELETE)
3. Enter the URL
4. Go to "Authorization" tab
5. Select "Bearer Token" type
6. Paste your JWT token
7. Go to "Body" tab for POST/PUT requests
8. Select "raw" and "JSON"
9. Add your request body
10. Click "Send"

## Error Responses

### 401 Unauthorized

If you receive this error, check:

- Token is included in the Authorization header
- Token is properly formatted: `Bearer <token>`
- Token hasn't expired
- JWT_SECRET matches between token generation and validation

```json
{
  "statusCode": 401,
  "message": "Unauthorized"
}
```

## Architecture

The authentication implementation follows the hexagonal architecture pattern:

```
src/
└── infrastructure/
    └── auth/
        ├── auth.module.ts       # Auth module configuration
        ├── jwt.strategy.ts      # JWT validation strategy
        └── jwt-auth.guard.ts    # JWT guard for protecting routes
```

### How It Works

1. **JwtStrategy**: Validates the JWT token and extracts the payload
2. **JwtAuthGuard**: Protects routes by checking for a valid JWT token
3. **@UseGuards(JwtAuthGuard)**: Decorator applied to protected endpoints

## Integration with User Service

In a production environment, you should:

1. Implement a separate authentication service
2. Create login/register endpoints that generate JWT tokens
3. Include user ID from the token payload in request handlers
4. Validate user permissions based on the token

### Example: Extract User from Token

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user; // Contains { userId, email }
  },
);

// Usage in controller:
@Post()
@UseGuards(JwtAuthGuard)
async createDonation(
  @Body() donation: Omit<Donation, 'id'>,
  @CurrentUser() user: { userId: string; email?: string }
) {
  // Use user.userId instead of donation.userId
  return this.donationService.createDonation({
    ...donation,
    userId: user.userId,
  });
}
```

## Security Best Practices

1. **Strong Secrets**: Use cryptographically strong random secrets

   ```bash
   node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
   ```

2. **Short Expiration**: Keep token expiration time reasonable (1-24 hours)

3. **HTTPS Only**: Always use HTTPS in production

4. **Token Storage**:
   - Frontend: Store in httpOnly cookies (preferred) or localStorage
   - Never store in regular cookies or URL parameters

5. **Refresh Tokens**: Implement refresh token mechanism for better UX

6. **Rate Limiting**: Add rate limiting to prevent brute force attacks

7. **Logging**: Log authentication failures for security monitoring

## Troubleshooting

### Token Validation Fails

1. Check JWT_SECRET environment variable is set
2. Ensure token is not expired
3. Verify token format matches the expected payload structure

### Guard Not Applied

1. Ensure AuthModule is imported in the module
2. Check @UseGuards decorator is applied to the method
3. Verify passport and JWT packages are installed

### Token Extraction Issues

1. Verify Authorization header format: `Bearer <token>`
2. Check for extra spaces or newlines in the token
3. Ensure token is properly encoded

## Next Steps

1. Implement user authentication service
2. Add user registration and login endpoints
3. Implement refresh token mechanism
4. Add role-based access control (RBAC)
5. Implement token revocation/blacklisting
6. Add rate limiting middleware
7. Set up monitoring and logging

## Additional Resources

- [NestJS JWT Documentation](https://docs.nestjs.com/security/authentication)
- [Passport JWT Strategy](http://www.passportjs.org/packages/passport-jwt/)
- [JWT.io - Token Debugger](https://jwt.io)
